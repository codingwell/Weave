// Copyright (c) 2012 Thomas Suckow
// are made available under the terms of the Eclipse Public License v1.0 
// which accompanies this distribution, and is available at 
// http://www.eclipse.org/legal/epl-v10.html

package net.codingwell.weave.languages.verilog

import net.codingwell.weave._
import scala.collection.{ mutable => mu, immutable => im }

class GeneratorState () {

  var identifierSalt:Int = 0
  var genout:String = "// Generated by WEAVE\n\n"

  def generateIdentifier():String = {
    
    val id = new mu.StringBuilder
    var count = identifierSalt
    do {
      val mod = count % 26
      count = count / 26
      val ch = ('a' + mod).toChar
      id append ch
    } while ( count > 0 )
    
    identifierSalt = identifierSalt + 1

    "_$_" + id.toString
  }
}

case class TopLevelInput ( val name:String ) extends ConnectionSignal {}

class VerilogGeneratorVisitor() extends GeneratorVisitor {

  def generate( toplevel:ModuleSymbol ):Unit = {
    val state = new GeneratorState

    println("Generating TopLevel: " + toplevel.name)

    state.genout += "module " + toplevel.name + "( "

    var outputs:im.List[ModuleParameter] = im.List.empty
    var topInstance = new ModuleInstance( toplevel )

    var first = true;
    toplevel.parameters.orderedParameters foreach { v => {
      println("Parameter: " + v.name)
      if( !first ) state.genout += ", "
      first = false;

      if( (v.direction equals "out") || (v.direction equals "ret") ) {
        state.genout += "output wire " + v.name
        outputs = v :: outputs
      } else if( v.direction equals "in" ) {
        state.genout += "input wire " + v.name
        topInstance.inputs += ( ( v.signal, new TopLevelInput( v.name ) ) )
      } else {
        throw new Exception( "Unknown Parameter" )
      }
    }}
  
    state.genout += ");\n\n"

    outputs foreach { v =>
      handleSignal( v.name, v.signal )( state, im.List( topInstance ) )
    }
    
    state.genout += "endmodule"

    println( "Generated: \n\n" )
    println( state.genout )
    println( "\n\n" )
  }

  def handleSignal(target:String, connectionSignal:ConnectionSignal)( implicit state:GeneratorState, moduleStack:im.List[ModuleInstance] ):Unit = {
    connectionSignal match {
      case connection @ Connection() =>
        connection.input match {
          case Some( signal ) =>
            handleSignal( target, signal )
          case None =>
            println( "ERR: Connection has no signal!" )
        }

      case ModuleConnection( instance, instanceConnection ) =>
        println("Module Connection (" + instance.module.name + ")")
        handleSignal( target, instanceConnection )( state, instance :: moduleStack )

      case moduleInput @ ModuleInput(name) =>
        val instance = moduleStack.head
        println("Module: " + instance.module.name + "  Input: " + name )
        instance.inputs lift ( moduleInput ) match {
          case Some( signal ) =>
            handleSignal( target, signal )( state, moduleStack drop 1 )
          case None =>
            throw new Exception("Input is not connected")
        }

      case Gate_OR( a, b ) =>
        println( "OR-GATE" )
        val idA = state.generateIdentifier
        val idB = state.generateIdentifier
        state.genout += "\n"
        state.genout += "\t" + "wire " + idA + ";\n"
        state.genout += "\t" + "wire " + idB + ";\n"
        state.genout += "\t" + "assign " + target + " = " + idA + " | " + idB + ";\n"
        handleSignal( idA, a )
        handleSignal( idB, b )

      case Gate_AND( a, b ) =>
        println( "AND-GATE" )
        val idA = state.generateIdentifier
        val idB = state.generateIdentifier
        state.genout += "\n"
        state.genout += "\t" + "wire " + idA + ";\n"
        state.genout += "\t" + "wire " + idB + ";\n"
        state.genout += "\t" + "assign " + target + " = " + idA + " & " + idB + ";\n"
        handleSignal( idA, a )
        handleSignal( idB, b )

      case Gate_XOR( a, b ) =>
        println( "XOR-GATE" )
        val idA = state.generateIdentifier
        val idB = state.generateIdentifier
        state.genout += "\n"
        state.genout += "\t" + "wire " + idA + ";\n"
        state.genout += "\t" + "wire " + idB + ";\n"
        state.genout += "\t" + "assign " + target + " = " + idA + " ^ " + idB + ";\n"
        handleSignal( idA, a )
        handleSignal( idB, b )

      case TopLevelInput( name ) =>
        println( "Traced ouptut to toplevel input: " + name )
        state.genout += "\t" + "assign " + target + " = " + name + ";\n"
      case unknown =>
        println("** Unknown ConnectionSignal: " + unknown)
    }
  }

}
